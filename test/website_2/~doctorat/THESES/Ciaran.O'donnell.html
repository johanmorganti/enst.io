<html>
<head>
<title>
Compilation de haut niveau pour les machines de bas niveau - Ciaran O'donnell
</title>

	       <!*** Definition des meta pour l'indexation ***>

<meta name="Auteur" content=" Ciaran O'donnell ">
<meta name="Titre" content=" Compilation de haut niveau pour les machines de bas niveau ">
<meta name="Title" content="  ">
<meta name="Departement" content=" Informatique ">

<meta name="Directeur" content=" Ulrich Finger ">
<meta name="Laboratoire" content="  ">
<meta name="Universite" content="  ">

<meta name="Resume" content="  La complexité d'un compilateur pour RISC se chiffre en centaines de milliers de lignes de code source. Nous présentons une nouvelle façon d'organiser un compilateur, axée autour d'une représentation de très haut niveau du programme. D'abord, un Graphe de Contrôle de Flux (CFG) est construit en éliminant les artifices du langage source. Ensuite, des instructions sont sélectionnées pour les expressions du CFG. En même temps, les expressions redondantes et les affectations sont éliminées et les informations nécessaires pour l'optimisation sont déduites. Il s'agit du Graphe des Dépendences de Contrôle et la forme à Affectation Statique Unique (forme SSA). Nous montrons que la liaison d'arguments dans le "continuation passing style" correspond aux pseudo-affectations utilisées par la forme SSA. Les appels de procédure peuvent être élegamment représentés en ajoutant une gestion des fermetures à la représentation. Nous montrons comment des traces mesurées à l'exécution peuvent servir pour guider l'optimisation. Nous montrons comment organiser les blocs de base en mémoire afin de limiter les branchements. L'ordonnancement optimal des blocs de bases en présence d'une anté-mémoire "direct mapped" est caracterisé comme un problème de partitionnement de graphe. Le compilateur C qui génère la représentation intermédiaire nécessite 13.000 lignes de code seulement.

 ">
<meta name="Abstract" content="  The complexity of a RISC compiler is measured in hundreds of thousands of lines of source code. We present a new way to organize the compiler, centered around a very high level representation of the program. First, a Control flow Graph (CFG) is built by eliminating artifacts of the source language. Next; instructions are chosen for the expressions of the CFG. At the same time; redundant expressions and assignments are eliminated and the information required for optimisation (the Control Dependence Graph and SSA form) is derived. We show that argument binding in the Continuation Passing Style is the same thing as the pseudo assignments SSA form uses. Procedure calls can be represented very nicely by adding instructions for closure management to the representation. We show how profile information from execution can be used to guide optimization. We show how to organize the order of basic blocks in memory to limit the number of branches. The optimal ordering of basic blocks in presence of a direct mapped cache is characterized in ter,s of two graph clustering problems. The C compiler to generate the intermediate representation reauires only 13.000 lines of code.
 ">
<meta name="Motcle" content="  ">
<meta name="Photo" content=" http:// ">
<meta name="Page" content=" http:// ">
<meta name="Statut" content=" Soutenue ">
<meta name="Date" content="  20 octobre 94 ">
<meta name="Lieu" content="  ">
<meta name="Login" content=" doctorat ">


</head>

  <body BGCOLOR="#ffffff" text="#101077" LINK="#000fff" 
  VLINK="#7070ff"><font size=+1></body>

	            <!*** Presentation ***>

  <h1 align=center>
  <IMG SRC="../gif/graduate.gif" align=left border=0>
  <A HREF="#anglais">
  <IMG SRC="http://www.enst.fr/images/english.gif" align=right border=0>
  </A>
  Compilation de haut niveau pour les machines de bas niveau  </h1>
  <IMG SRC="../gif/lignes/oranj.gif" align=left>
  <br> <br><h2 align="right"> Auteur :   Ciaran O'donnell<br></h2>
             <h3 align="right">Th&egrave;se de  l'ENST </h3> 
             <h3 align="right">D&eacute;partement    Informatique<br>
             </h3><br clear=all> <h3><br>R&eacute;sum&eacute : </h3> La complexité d'un compilateur pour RISC se chiffre en centaines de milliers de lignes de code source. Nous présentons une nouvelle façon d'organiser un compilateur, axée autour d'une représentation de très haut niveau du programme. D'abord, un Graphe de Contrôle de Flux (CFG) est construit en éliminant les artifices du langage source. Ensuite, des instructions sont sélectionnées pour les expressions du CFG. En même temps, les expressions redondantes et les affectations sont éliminées et les informations nécessaires pour l'optimisation sont déduites. Il s'agit du Graphe des Dépendences de Contrôle et la forme à Affectation Statique Unique (forme SSA). Nous montrons que la liaison d'arguments dans le "continuation passing style" correspond aux pseudo-affectations utilisées par la forme SSA. Les appels de procédure peuvent être élegamment représentés en ajoutant une gestion des fermetures à la représentation. Nous montrons comment des traces mesurées à l'exécution peuvent servir pour guider l'optimisation. Nous montrons comment organiser les blocs de base en mémoire afin de limiter les branchements. L'ordonnancement optimal des blocs de bases en présence d'une anté-mémoire "direct mapped" est caracterisé comme un problème de partitionnement de graphe. Le compilateur C qui génère la représentation intermédiaire nécessite 13.000 lignes de code seulement.


              <H3> Mot-Cl&eacute;s :</H3> 
               <h3> <br> Directeur de la th&egrave;se : Ulrich Finger </h3>
               <hr> <h3> Th&egrave;se Soutenue  
                    <br><i>Date de soutenance :   20 octobre 94</i></h3> <A NAME="anglais"> <br><align="left">
              <IMG SRC="../gif/lignes/oranj.gif">
              <H2> Title : </H2> <H3> Abstract :</H3>  The complexity of a RISC compiler is measured in hundreds of thousands of lines of source code. We present a new way to organize the compiler, centered around a very high level representation of the program. First, a Control flow Graph (CFG) is built by eliminating artifacts of the source language. Next; instructions are chosen for the expressions of the CFG. At the same time; redundant expressions and assignments are eliminated and the information required for optimisation (the Control Dependence Graph and SSA form) is derived. We show that argument binding in the Continuation Passing Style is the same thing as the pseudo assignments SSA form uses. Procedure calls can be represented very nicely by adding instructions for closure management to the representation. We show how profile information from execution can be used to guide optimization. We show how to organize the order of basic blocks in memory to limit the number of branches. The optimal ordering of basic blocks in presence of a direct mapped cache is characterized in ter,s of two graph clustering problems. The C compiler to generate the intermediate representation reauires only 13.000 lines of code.
 <br>
              <align="left">
               <IMG SRC="../gif/lignes/oranj.gif">
	              <!*** Liens possibles ***>

             <h4> <A HREF="../theses_enst.html">
              Effectuer une nouvelle recherche ?</A>
              <br></h4> </h4>
                </body>
                </html>